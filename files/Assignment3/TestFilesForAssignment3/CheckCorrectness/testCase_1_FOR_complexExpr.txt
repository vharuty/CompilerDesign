// checking correctness of <for> statement 
//using complex expressions
class ABC{
	float i;
	float j;
	float b[10];
	CDE cde[10][10];
	CDE cde2;
	BCD bcd;

	int func1(){
		for( int i =1;  i <= i or bcd.convert(b[i]) / (-1)and(bcd.convert(b[i])); i = i or 1) // <or> works as an additional operator by given grammar
			// even though it is has nological  meanning, but it is allowed to use	
				for( int j = cde[j][i].a; j <= cde2.returnObj(i, j) * free_func1(); j = j or  free_func1()){
					put(cde2.returnObj(i, j) * free_func1());
					get(cde[j][i].a);

				};;

	};


};
class BCD{

	int function_float(float a, float b){
		return(convert(a) and convert(b) / (convert(a) or convert(b)));
	};

	int convert(float k){
		int a;
		return (a);
	};

};

class CDE{
	BCD bcd;
	int a;
	float c;
	float d;
	int returnObj(int a, int bc){
		int b[2][6];
		for(int i = 1; i < 10; i = i +1)
			for(int j = j+ b[1][1] and a * a or b[i][j] ; j <= a * bcd.function_float(c, d); j = j+ b[1][1] and a * a or b[i][j] / j+ b[j][i] and a * (-a) * (-1) or b[i][j]) // <and>, <or>, <sign factor>
				a = a*b[i][j] + bcd.function_float(c, d);;;
	};

};

program{
	CDE cde;
	ABC  abc;
	int a;
	float c;
	float d;
						//returns object of type <CDE>	
	a  = free_func1() + cde.returnObj( a, cde.bcd.function_float(c,d)) / abc.func1(); // complex expression with complex nested return type

};

int free_func1(){

	BCD bcd;
	int a;
	float c;
	float d;
	int b[2][6];
	
		for(int i = 1; i < 10; i = i +1)
			for(int j = j+ b[1][1] and a * a or b[i][j] ; j <= a * bcd.function_float(c, d); j = j+ b[1][1] and a * a or b[i][j] / j+ b[j][i] and a * (-a) * (-1) or b[i][j]) // <and>, <or>, <sign factor>
				a = a*b[i][j] + bcd.function_float(c, d);;;
	return(a);

};