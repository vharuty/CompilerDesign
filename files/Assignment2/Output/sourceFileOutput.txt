class	CLASS	4
ABC	ID	4
{	LBRACE	4
BCD	ID	6
bcd	ID	6
;	SEMICOLON	6
int	INT	7
f1	ID	7
(	LPAREN	7
cl1	ID	7
par1	ID	7
,	COMMA	7
float	FLOAT	7
par2	ID	7
)	RPAREN	7
{	LBRACE	7
cl3	ID	8
par3	ID	8
;	SEMICOLON	8
par3	ID	10
=	assignOp	10
2	NUM	10
*	multOp	10
par3	ID	10
+	addOp 	10
4	NUM	10
;	SEMICOLON	10
}	RBRACE	11
;	SEMICOLON	11
BCD	ID	13
f2	ID	13
(	LPAREN	13
)	RPAREN	13
{	LBRACE	13
return	RETURN	15
(	LPAREN	15
10	NUM	15
)	RPAREN	15
;	SEMICOLON	15
}	RBRACE	17
;	SEMICOLON	17
}	RBRACE	19
;	SEMICOLON	19
class	CLASS	21
CCC	ID	21
{	LBRACE	21
int	INT	23
fff2	ID	23
(	LPAREN	23
)	RPAREN	23
{	LBRACE	23
return	RETURN	25
(	LPAREN	25
10	NUM	25
)	RPAREN	25
;	SEMICOLON	25
}	RBRACE	27
;	SEMICOLON	27
}	RBRACE	29
;	SEMICOLON	29
program	PROGRAM	31
{	LBRACE	31
myClass	ID	32
c1	ID	32
[	LSQRBRACE	32
10	NUM	32
]	RSQRBRACE	32
;	SEMICOLON	32
ABC	ID	33
abc	ID	33
;	SEMICOLON	33
int	INT	34
a	ID	34
;	SEMICOLON	34
CCC	ID	35
c_class	ID	35
;	SEMICOLON	35
c1	ID	36
[	LSQRBRACE	36
4	NUM	36
]	RSQRBRACE	36
.	DOT	36
abc	ID	36
.	DOT	36
g	ID	36
[	LSQRBRACE	36
10	NUM	36
]	RSQRBRACE	36
=	assignOp	36
2	NUM	36
;	SEMICOLON	36
a	ID	37
=	assignOp	37
f_doesNotExist	ID	37
(	LPAREN	37
)	RPAREN	37
;	SEMICOLON	37
a	ID	38
=	assignOp	38
c_class	ID	38
.	DOT	38
f2	ID	38
(	LPAREN	38
)	RPAREN	38
;	SEMICOLON	38
}	RBRACE	39
;	SEMICOLON	39
ABC	ID	41
free_f1	ID	41
(	LPAREN	41
int	INT	41
a	ID	41
)	RPAREN	41
{	LBRACE	41
for	FOR	43
(	LPAREN	43
int	INT	43
i	ID	43
=	assignOp	43
1	NUM	43
;	SEMICOLON	43
j	ID	43
<	relOp	43
10	NUM	43
;	SEMICOLON	43
k	ID	43
=	assignOp	43
k	ID	43
+	addOp 	43
1	NUM	43
)	RPAREN	43
{	LBRACE	43
a	ID	45
=	assignOp	45
a	ID	45
*	multOp	45
i	ID	45
;	SEMICOLON	45
}	RBRACE	46
;	SEMICOLON	46
}	RBRACE	47
;	SEMICOLON	47
BCD	ID	49
free_2	ID	49
(	LPAREN	49
)	RPAREN	49
{	LBRACE	49
}	RBRACE	51
;	SEMICOLON	51
